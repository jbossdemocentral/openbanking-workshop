:3scale-admin-url: https://{user-username}-admin.{openshift-app-host}/p/login
:3scale-url: https://www.3scale.net/
:user-password: openshift

= Lab 02 - Managing API Endpoints

In this lab you will be adding management capabilities to your API to give you control and visibility of it's usage.

*Overview*

Upgrading services to APIs allow us to share within other teams or even third party providers some of the organization services. The API Management capabilities enable us to have better control over the way consumers access the APIs.

*Why Red Hat?*

Red Hat provides one the leading API Management tools that provides API management services. The link:{3scale-url}[3scale API Management] solution enables you to quickly and easily protect and manage your APIs.

*Credentials:*

Your username is: `{user-username}` +
Your password is: `{user-password}`

[time=5]
[id='import-api']
== Import from Fuse Online

. Log in to link:{3scale-admin-url}[3scale Admin, window="_blank"] web console using `{user-username}` and password: `{user-password}`.
+
The dashboard will show a summary of the trends in usage of the platform, in terms of developers signups, usage of APIs and message sent and received.
+
image::images/lab2-100.png[lab2-100, role="integr8ly-img-responsive"]
+
Let’s start managing and protecting the API we just created on Fuse Online.
. Click on the green button **New API**.
+
image::images/lab2-101.png[lab2-101, role="integr8ly-img-responsive"]
. Click on **Authenticate to enable this option**, login with your credentials and click on **Allow selected permissions**.
+
image::images/lab2-102.png[lab2-102, role="integr8ly-img-responsive"]
. Select **Import from OpenShift**. It will populate the __Namespace__ and __Name__ fields with the information from the service you created in the previous lab. Click **Create Service** to continue.
+
image::images/lab2-103.png[lab2-103, role="integr8ly-img-responsive"]
. You will be redirected to the Dashboard view where a success message should appear as shown.
+
image::images/lab2-104.png[lab2-104, role="integr8ly-img-responsive"]

NOTE: Once the service is created you will see that in the dropdown menu where you can also see **Audience**.

[time=5]
[id='configure-api']
== API Configuration

We can now proceed on changing the details of the configuration of the API and publish the update on the Developer Portal so that the consuming Developers can sign up for the open financial API.

This is where you configure the rest of the details of the mapped and protected Service. The private base URL should already be filled with the details coming from the auto-discovery feature.

. After a few seconds your API should be added to the services list. Type in `BANK` in the search field to filter the list and show our API. Then click in the **INTEGRATE THIS API** link.
+
image::images/lab2-200.png[lab2-200, role="integr8ly-img-responsive"]
. We have the section where we map the Backend API (or in this case Integration service) and then 2 URLs where we expose the managed API on the staging first and production gateways or infrastructure. We will be changing the Staging and Public addresses of the gateway. In this case we are not going to use separate staging or public infrastructure so it can be the same address. 
. Click on the **edit APIcast configuration** link.
+
image::images/lab2-201.png[lab2-201, role="integr8ly-img-responsive"]
. Replace the **Staging Public Base URL** and the **Production Public Base URL** with the following value:
+
  https://open-bank-data-{user-username}.{openshift-app-host}:443
+
image::images/lab2-201a.png[lab2-201a, role="integr8ly-img-responsive"]
. We will now make sure we map a single endpoint or resource in 3scale and disallow any other endpoint (i.e. the other endpoints have not been implemented yet so we are protecting them from being exposed). Scroll down the page and click on the **MAPPING RULES** section link.
+
image::images/lab2-202.png[lab2-202, role="integr8ly-img-responsive"]
. The endpoint you want to map is `/open-data/banks$` (notice the $ at the end of the path that will allow us to make sure users cannot improperly access any other sub-resource). Click on the green pencil icon to edit the current mapping rule. 
+
image::images/lab2-203.png[lab2-203, role="integr8ly-img-responsive"]
. Type in the patter we will be allowing to process in this case is `/open-data/banks$`.
+
image::images/lab2-204.png[lab2-204, role="integr8ly-img-responsive"]
. Scroll down a little bit further and expand the **AUTHENTICATION SETTINGS**. 
+
image::images/lab2-205.png[lab2-205, role="integr8ly-img-responsive"]
. We see that we have already api key protection enabled, but we might want to pass this information as HTTP Header instead of HTTP parameter. Select **As HTTP Headers** under __Credentials location__ and change the **Auth user key** header name to `key`.
+
image::images/lab2-206.png[lab2-206, role="integr8ly-img-responsive"]
+
NOTE: You can also customize the error returned to the end user. 

[time=5]
[id='api-policies']
== API Policies

These are like additional plugin that you can configure to adapt the service to your own
preference.

. Scroll down the page and click on **POLICIES**.
+
image::images/lab2-300.png[lab2-300, role="integr8ly-img-responsive"]
. Click on **Add Policy**.
+
image::images/lab2-301.png[lab2-301, role="integr8ly-img-responsive"]
. Review the policies available out of the box with 3scale.
+
image::images/lab2-302.png[lab2-302, role="integr8ly-img-responsive"]
+
NOTE: Several policies are available and the list is always increasing. Two policies / functionalities are of importance: SOAP policy to map *SOAP* services and advanced rate limit functionalities with *Edge limiting* policy. 
. Click **Cancel** to return to close the API policies.
+
image::images/lab2-302a.png[lab2-302a, role="integr8ly-img-responsive"]
. Update the **API test GET request** field with the same pattern you are mapping `/open-data/banks` (notice the exclusion of the `$`).
+
image::images/lab2-303.png[lab2-303, role="integr8ly-img-responsive"]
+
Hitting the big blue button will allow you to do two things at once:
+
 - Update the service configuration on the platform
 - Test the configuration just uploaded to the gateway.
+
NOTE: The second one will fail since we are not providing any valid key, so we will get unauthorized request but the gateway will receive the updated configuration in any case. We will now fix the test request error as advised by the warning message.

[time=5]
[id='api-app-plans']
== Application Plans

Let’s switch to explaining the role of API contracts of Application Plans.

Within the red error message a link is generated **Start with creating an application plan**. Since we are creating a Service we will need to offer a way for Developers to subscribe to it and use it. Application plan are the way to do that (also known as API Contracts).

. Click on the **Start with creating an application plan** link.
+
image::images/lab2-400.png[lab2-400, role="integr8ly-img-responsive"]
. Click on **Create Application Plan**
+
image::images/lab2-401.png[lab2-401, role="integr8ly-img-responsive"]
. Fill out the **Name** and **System Name** fields on the __Create Application Plan__ form and then click the **Create Application Plan** button to submit the form.
+
image::images/lab2-402.png[lab2-402, role="integr8ly-img-responsive"]
+
NOTE: You can safely ignore for now the monetization options.

We see that we have 1 API contract (or Application Plan), but no application associated to it.
The application plans are in hidden state by default, so let’s publish this one so that it is usable
and visible on the Developer portal. Let’s open the application plan.
Main elements:
- Monetization settings (trial, setup, cost per month)
- Endpoint mapped (in this case generic Hits) and relative monetization and rate limiting
settings
Don’t modify anything beside filling Name and System name.

We can now switch to the Audience tab to create an Application to test the Configuration, by
clicking on Listing.
From here we can see how we can, as Provider, approve or deny Developers’ Accounts
registrations. Let’s click on the default Developer Account
We can see that the Developer has the default application associated, but it’s subscribed to the

default Service. We can also see the Developer user details.
Let’s click on Applications in the top level navigation and Create application
Here we can now subscribe the application to the Application plan we created on our new
Service from the drop down field available. Let’s fill in the rest of the fields with some basic
details and click the big blue button: Create Application.
We now have an assigned key so we can go back to the Configuration window of the API service
and make a successful test call. API -> Integration -> edit Apicast configuration
26
We now have a pre-populated key in the example curl statement, let’s try again testing the
deployed configuration.
As we can see we turned the testing into a success.
Let’s switch to the developers’ point of view by accessing the Developer portal. You can access
it by selecting in to the top menu in Audience -> Developer portal -> Visit Developer Portal
The sidebar allows us to edit pages of the Developer Portal live, but we are not interested in it
now so we can close it.
Let’s sign in with the default user credentials provided in the sidebar. This is the default
developer user, created for the default developer account [john / 123456]
27
We are now logged in the developer’s dashboard. Let’s see the Applications I have created
I can now use the credential that I have associated with the application and test the protected
service. Let’s move to the online API testing tool, https://apitester.com/
28
Use the URL for your API gateway, the following format should be configured in your service
already: https://userX.amp.apps.openbanking-fe8e.openshiftworkshop.com , remember the the
key Header and the associated value.
As we can see we succeed with 200 OK!
Let’s now just test with a wrong key or path then to confirm the role of API Management.
29
As expected we receive a Forbidden error.
Checkpoint
Break
Practical Part 2
RH SSO and 3SCALE OIDC
Let’s now improve the security of the managed integration service with OIDC. API key is not
really considered a safe method anymore and is vulnerable to many attacks.
After introducing content around OAuth and OIDC, let’s see the main elements of RH SSO
itself.
SINCE AS INTEGR8LY USERS YOU DON’T HAVE ACCESS TO THE RELATED RH SSO REALM,
YOU ARE GOING TO SEE HOW TO CONFIGURE A RH SSO CLIENT THAT WILL THEN BE USED
BY EVERYBODY IN THEIR 3SCALE OIDC CONFIGURATION.
DEMO ONLY
Let’s start with RH SSO main dashboard
 http://sso.apps.openbanking-fe8e.openshiftworksho p.com/auth/
30
The realms are like separate instances of the platform, dedicated to separating users and
applications. As we can see we can customize several aspects of the realm like the theme of the
login page or the the tokens’ default parameters. Endpoints -> OpenID Endpoint Configuration
This is where we can find the public endpoints of the Realm exposed by RH SSO (we are going
to be using this later).
Let’s now take a look at the Clients section.
31
Here we can configure the web or mobile applications that will authenticate using RH SSO as an
IDP (corresponding to applications in 3scale). As we can see there are some default clients
dedicated to authentication in the integr8ly environment.
Users -> View all users
Here we can see all the end users that are stored inside RH SSO, making it act as an IDM as
well. These are the end users of the applications created in the Clients section and they will be
able to authenticate through them. Let’s open one of these users’ details.
32
We can see here the type of information stored along with basic user details. The user profile
can be customized with additional attributes as well.
We will take advantage of one of the features available in OIDC and not in OAUTH which is
dynamic client registration.
Normally to make sure an API web application authenticates with RH SSO, we would need to
manually create the application on both platforms. With this feature, we let 3scale sync the
applications to RH SSO, as well as obviously authenticating our API calls. Let’s create a special
type of such Client in RH SSO under Threescale realm. Clients -> Create
Let’s call it sync-app and configure the other details required to let it communicate with 3scale.
33
We are going to give it only the rights to create applications on behalf of 3scale (service
accounts enabled only).
Save -> Service account roles
Add manage-clients to the assigned roles in this window, by picking realm-management in the
Client roles menu, this special role allows it to create application on behalf of API management.
Then click add selected
34
And now we are ready to use the client credentials inside 3scale OIDC configuration section.
To authenticate as we were an end user, we will need to create one test user, so let’s go to the
Users section and add a user
We will fill in all the user details and switch to user email verified
Now we will set the password, by going to credentials and setting it to password and reset
35
password.
We have now all the elements to proceed with the corresponding configuration on API
management to authenticate calls using our RH SSO.
LAB BEGINS
Let’s now switch back to 3scale to configure the API management side of OIDC authentication.
We can see that we have a fully configured API with API key as the Authentication method. We
are going to change it to the more secure OpenID Connect, to ensure our financial data are
protected from attacks performed when a key is compromised. Edit integration settings
36
We are going to change it to OpenID Connect. Update service
Clearly the platform is warning us that we have customers using this API and it might break
their application, changing the authentication method. In a real world case, we would inform the
developer in advance by using the messaging and notification functionality available within the
platform.
37
We have now changed the authentication method, we are just left with configuring the correct
IdP inside 3scale to make sure it is authenticating the requests with RH SSO. edit apicast
configuration
As we see we have a dedicated field for this purpose now: OpenID Connect Issuer
Let’s build a url of this format to use it:
38
http://client-id:client-secret@<idp-public-endpoint>
where client-id: sync-app
client secret: 5f8f3908-dc47-4b24-a9aa-44f6860e1144
idp-public-endpoint:
sso.apps.openbanking-fe8e.openshiftworkshop.com/auth/realms/threescale
Lastly, change the Credentials location to As HTTP Headers
And update the staging environment and promote the configuration to production by clicking
the blue button Promote to production.
Let’s now switch user perspective and get in the shoes of the developer and open their
Applications section.
39
We can see the secret of their application is absent as is the redirect URL. We are going to
generate the first and add as redirect url the following https://openidconnect.net/callback (we
are going to explain why in a moment).
Let’s make sure that the application is now aligned in terms of credentials both in 3scale and
RH SSO.
40
41
All looks good! Let’s now try to authenticate the end user, using OpenID Connect.
We are going to need a special web client, a little bit more intelligent than just the API tester:
https://openidconnect.net/
Let’s configure it with the correct parameters from the previous steps. Configuration
Let’s change the server template to custom and input in the discovery URL the one we opened
before in our RH SSO realm
 http://sso.apps.openbanking-fe8e.openshiftworksho p.com/ auth/realms/threescale/.wellknown/openid-configuration
And click on USE DISCOVERY DOCUMENT
We are going to use the client id and secret as from the application created in the 3scale
developer portal / 3scale admin portal or RH SSO since they are all the same.
And lastly as scope we are going to add openid and email. SAVE
42
Start the authentication flow by hitting start. You are going to be redirected to the RH SSO
login interface where you can use the default user details and password we saw before (john /
password). Once you login you will receive a temporary code to be exchanged for the final
credentials or access token.
43
Hit Exchange
44
You will receive the “access_token” which is an expiring credential that we will be using to
authenticate with 3scale to get access to the configured API using OpenID Connect. We can
see that another important piece of information is shown there regarding when this credential
will expire “expires_in”.
We can hit NEXT and id_token will also be shown, which contains more user related details.
45
We can decode the information on the website JWT.io and found our user details once again as
passed to the Backend service.
Let’s now go back to https://openidconnect.net/ website and copy the “access_token” value in
the step 2 (the long string).
46
It should look something like this:
eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRa1RJX2VwS2IwNVpFSkp3ZTd1cnFQUWtjSERNRi1SMnhGcE1tZUJ2aC1VIn0.eyJqdGkiOiIyYzJmZjQ5ZS01MDY4LTQ0
MjQtYTRiNS05MWU3OTk3MTM0YTMiLCJleHAiOjE1NDczOTc1NTIsIm5iZiI6MCwiaWF0IjoxNTQ3Mzk2NjUyLCJpc3MiOiJodHRwczovL3NlY3VyZS1zc28tc3NvLmFwcHMub3Bl
bi1iYW5raW5nLm9wZW50cnkubWUvYXV0aC9yZWFsbXMvb3BlbnNoaWZ0IiwiYXVkIjoiNWJjOTRmNmEiLCJzdWIiOiIyMzZjZDRhMy01MGM2LTQ3YjQtYWUzZC05ODdiYjA1ZT
k4MzYiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiI1YmM5NGY2YSIsImF1dGhfdGltZSI6MTU0NzM5NTg3Niwic2Vzc2lvbl9zdGF0ZSI6ImZhMTQ5YjhiLWQ0ZTktNDliZS05NWIwLTk2
MTNmZjBhNTViZCIsImFjciI6IjAiLCJhbGxvd2VkLW9yaWdpbnMiOltdLCJyZWFsbV9hY2Nlc3MiOnsicm9sZXMiOlsidW1hX2F1dGhvcml6YXRpb24iXX0sInJlc291cmNlX2FjY2Vzcy
I6eyJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJ
ldmFsczk4QGV4YW1wbGUuY29tIiwiZW1haWwiOiJldmFsczk4QGV4YW1wbGUuY29tIn0.O7y6GDFq5CajAT0DkywEuQqEuD5H7_YMqrVC4AMPthZm_xZ_DAPBEqj3mmzp1o1JOo0_4pMxNgKpyyqCQiFY79GRS5lJE6aVrZK53rQkud5dIaZAE1-ryiD8CtP_MrQtsTS7bVKbaFyCXNyFfxy3cTER8GnGG90OlYPXpy5M954sIcp4CWXxA7ZwVEuQNRRs5w2G2TCjrFyQjCzslNFwDRtADjbMiY7kq1cwRB5qM9ipdEEIigDnH8dietiOZgY24sK10vtowjz_CHuWr5W3474dAZVF
C7utwStl_bNcoj1gENRcz5cP7fH7Nim8e4itWoSVPRVYcfDHyYb9zixQ
We are going to use this as a Header in our call towards the OpenID protected service.
Let’s go back to our api tester and add this as an Authorization header. The format is
Authorization Bearer <access_token_value_here>
Let’s hit Test
47
And success!
The work done by the API management behind the curtain is quite impressive:
● Check for the validity of the access token credentials (not expired, legit and associated
to the correct application)
● Check for rate limits on the application triggering the call
● Apply monetization rules to the call
● Apply any additional policy that might modify the call in real time
● Report the traffic back to the analytics component
Checkpoint
Improved security to the highest grade possible while using standards.
48
OpenShift (optional)
LAB BEGINS
As user you will login into openshift and it already looks evident that the end user has been
profiled as developer on OpenShift as he has access only to Objects and Projects he created.
If we click on the fuse project we will be able to access to the Fuse Online installation dedicated
to the user. We would also be able to see any integration project running alongside Fuse
installation.
If we switch to the Cluster console, this will give us some Operations details on the project
created or assigned to our user.
This type of console is also used by Operations administrators to check the health of OpenShift.
We can see the RBAC in action if we click on Home -> Status
49
The Project default is excluded from the scope of any evals users, since it can contain system
components and privileged objects.
We can just switch to the Fuse project to see if there anything wrong with it in the cluster.
We will now try as bad intentioned user to change some parameters around the installed
products.
50
51
As we can see we tried to kill one of the running components of our integration platform with
no success, because of the roles assigned to my user.
DEMO ONLY
Let’s see the magic introduced by OpenShift and login as administrator of the platform once
again.
We now have full access to all the platforms from all users. We will open as admin one of the
Fuse projects and open one of the components of Fuse Online.
52
We are going to test the auto healing capabilities of the platform by killing one if its running
components, in particular the one providing the UI service.
53
As you can see we just deleted a Pod and we will verify that UI is broken by accessing the
interface of Fuse Online
54
As we can see the component auto-healed thanks to OpenShift features and in a few seconds
we have a GUI running once again for the integration platform.
55
Q&A
Common issues
● openidconnect.net client might have an additional space in the redirect_uri field. That’s
a client bug, you can fix it by adding an additional redirect URIs in RH SSO with a space
preceding the URL: “ https://openidconnect.net/callback”
● The installation of RH SSO might have some certificate issues, so might need to use
instead a RH SSO deployed somewhere else or using the HTTP only route as suggested
in the tutorial
● The database is deployed on ElephantSQL on a free tier, which allows only so many
concurrent connections. You might receive a limit reached if too many users are trying
the Open Data Bank API at the same time
56